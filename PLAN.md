# FastJson - 제로 설정 JSON Source Generator

## 개요

```csharp
// 이것만 쓰면 됨
var json = FastJson.Serialize(user);
var user = FastJson.Deserialize<User>(json);

// 어트리뷰트 없음, Context 없음, 설정 없음
```

### 문제점 (기존 System.Text.Json AOT)

```csharp
// DTO 100개면 이걸 100번 써야 함
[JsonSerializable(typeof(User))]
[JsonSerializable(typeof(Address))]
[JsonSerializable(typeof(Order))]
[JsonSerializable(typeof(Product))]
// ... 100줄 ...
public partial class AppJsonContext : JsonSerializerContext { }
```

### 해결책 (FastJson)

- Source Generator가 `FastJson.Serialize<T>()` / `FastJson.Deserialize<T>()` 호출 자동 감지
- 사용된 타입 `T` 자동 수집
- 중첩 타입 재귀 분석
- JsonTypeInfo 코드 자동 생성
- **개발자 작업: 없음**

---

## 기술 분석

### Microsoft가 구현 안 한 이유

| 이유 | 설명 |
|------|------|
| Source Generator 체이닝 불가 | Generator A의 출력을 Generator B가 볼 수 없음 |
| TypeInfo 직접 생성 필요 | STJ Generator 전체를 다시 만들어야 함 |
| 우선순위 | AOT/Source Generator 기본 기능 개발이 먼저 |
| 안전성 | "explicit model"이 더 안전하다고 판단 |

> GitHub Issue #45448 (2020년): "In the future we can introduce an implicit model..."  
> 5년 지났지만 아직 미구현

### FastJson 접근 방식

```
STJ Generator 의존 ❌ (체이닝 문제)
STJ Generator 대체 ✅ (직접 TypeInfo 생성)
```

---

## 프로젝트 구조

```
FastJson/
├── FastJson/                          # 런타임 라이브러리
│   ├── FastJson.csproj                    net6.0
│   └── FastJson.cs                        public API
│
├── FastJson.Generator/                # Source Generator
│   ├── FastJson.Generator.csproj          netstandard2.0
│   ├── FastJsonGenerator.cs               메인 Generator
│   ├── TypeCollector.cs                   타입 재귀 수집
│   ├── TypeInfoEmitter.cs                 JsonTypeInfo 코드 생성
│   ├── SerializerEmitter.cs               Serialize 코드 생성
│   └── DeserializerEmitter.cs             Deserialize 코드 생성
│
├── FastJson.Analyzer/                 # Roslyn Analyzer
│   └── FastJsonAnalyzer.cs                컴파일 타임 검증
│
└── FastJson.Tests/
```

---

## 기술 스택

| 항목 | 값 |
|------|-----|
| 런타임 타겟 | net6.0 (최소) |
| Generator 타겟 | netstandard2.0 |
| Roslyn 버전 | Microsoft.CodeAnalysis.CSharp 4.0.1 |
| SDK 요구사항 | .NET 6 SDK 이상 |

### .NET 6 필수인 이유

- `JsonSerializerContext` - .NET 6에서 도입
- `JsonMetadataServices` - .NET 6에서 도입
- `IIncrementalGenerator` - .NET 6 SDK에서 도입

---

## 구현 범위

### 지원 타입

#### Primitive
```
bool, byte, sbyte, short, ushort, int, uint, long, ulong,
float, double, decimal, char, string
```

#### Common
```
DateTime, DateTimeOffset, DateOnly, TimeOnly, TimeSpan,
Guid, Uri, Version, Enum, Nullable<T>
```

#### Collections
```
T[], List<T>, IList<T>, ICollection<T>, IEnumerable<T>,
Dictionary<K,V>, IDictionary<K,V>, HashSet<T>, ISet<T>
```

#### Object
```
class, record, struct, record struct
```

### 지원 어트리뷰트

| 어트리뷰트 | 용도 |
|-----------|------|
| `[JsonPropertyName]` | 프로퍼티 이름 변경 |
| `[JsonIgnore]` | 직렬화 제외 |
| `[JsonInclude]` | private/field 포함 |
| `[JsonConstructor]` | 역직렬화 생성자 지정 |
| `[JsonConverter]` | 커스텀 컨버터 |
| `[JsonNumberHandling]` | 숫자 처리 방식 |
| `[JsonRequired]` | 필수 프로퍼티 |

### 생성자 처리 규칙

1. `[JsonConstructor]` 있으면 → 해당 생성자 사용
2. 없으면 → 기본 생성자 사용
3. 기본 생성자 없으면 → 매개변수 가장 많은 public 생성자
4. 매개변수명 ↔ 프로퍼티명 매칭 (대소문자 무시)

---

## 생성 코드 예시

### 사용자 코드

```csharp
public record User(int Id, string Name, Address Address);
public record Address(string City, string Country);

var json = FastJson.Serialize(user);
var user = FastJson.Deserialize<User>(json);
```

### Generator가 생성하는 코드

```csharp
// <auto-generated/>
#nullable enable

internal static class FastJsonTypeInfo
{
    private static JsonSerializerOptions? _options;
    public static JsonSerializerOptions Options => _options ??= CreateOptions();
    
    private static JsonSerializerOptions CreateOptions()
    {
        var options = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
        };
        options.TypeInfoResolver = FastJsonContext.Default;
        return options;
    }
}

internal partial class FastJsonContext : JsonSerializerContext
{
    private static FastJsonContext? _default;
    public static FastJsonContext Default => _default ??= new FastJsonContext();
    
    // User TypeInfo
    private JsonTypeInfo<User>? _User;
    public JsonTypeInfo<User> User => _User ??= CreateUserTypeInfo();
    
    private JsonTypeInfo<User> CreateUserTypeInfo()
    {
        var info = JsonMetadataServices.CreateObjectInfo<User>(
            options: Options,
            createObjectFunc: null,
            propInitFunc: static () => new JsonPropertyInfo[]
            {
                CreatePropertyInfo<int>("Id", "id", 
                    static obj => ((User)obj).Id, 
                    null),
                CreatePropertyInfo<string>("Name", "name",
                    static obj => ((User)obj).Name,
                    null),
                CreatePropertyInfo<Address>("Address", "address",
                    static obj => ((User)obj).Address,
                    null),
            },
            constructorFunc: static args => new User(
                (int)args[0]!,
                (string)args[1]!,
                (Address)args[2]!
            ),
            constructorParameterMetadataInitializer: static () => new JsonParameterInfoValues[]
            {
                new() { Name = "id", ParameterType = typeof(int), Position = 0 },
                new() { Name = "name", ParameterType = typeof(string), Position = 1 },
                new() { Name = "address", ParameterType = typeof(Address), Position = 2 },
            }
        );
        return info;
    }
    
    // Address TypeInfo
    private JsonTypeInfo<Address>? _Address;
    public JsonTypeInfo<Address> Address => _Address ??= CreateAddressTypeInfo();
    // ...
}

public static partial class FastJson
{
    public static string Serialize<T>(T value)
    {
        return JsonSerializer.Serialize(value, FastJsonTypeInfo.Options);
    }
    
    public static T? Deserialize<T>(string json)
    {
        return JsonSerializer.Deserialize<T>(json, FastJsonTypeInfo.Options);
    }
}
```

---

## Analyzer 규칙

| ID | 심각도 | 설명 |
|----|--------|------|
| FJ001 | Error | 제네릭 타입 파라미터 사용 불가 (`FastJson.Deserialize<T>()` 에서 T가 타입 파라미터) |
| FJ002 | Error | 지원하지 않는 타입 (object, dynamic, 익명 타입 등) |
| FJ003 | Warning | 타입 깊이 초과 (재귀 깊이 20 초과) |
| FJ004 | Warning | 타입 수 초과 (수집된 타입 500개 초과) |
| FJ005 | Error | 순환 참조 감지 (A → B → A) |
| FJ006 | Info | 외부 타입 사용 (NuGet 패키지 타입 직렬화 시 알림) |

---

## 타입 수집 알고리즘

```csharp
HashSet<ITypeSymbol> CollectAllTypes(ITypeSymbol rootType)
{
    var result = new HashSet<ITypeSymbol>(SymbolEqualityComparer.Default);
    var queue = new Queue<ITypeSymbol>();
    queue.Enqueue(rootType);
    
    while (queue.Count > 0 && result.Count < MaxTypes)
    {
        var type = queue.Dequeue();
        
        if (!result.Add(type)) continue;  // 중복 방지
        if (IsPrimitive(type)) continue;   // primitive 스킵
        
        // 제네릭 타입 인자 (List<T>, Dictionary<K,V>)
        if (type is INamedTypeSymbol named && named.IsGenericType)
        {
            foreach (var typeArg in named.TypeArguments)
                queue.Enqueue(typeArg);
        }
        
        // 프로퍼티 타입들
        foreach (var member in type.GetMembers())
        {
            if (member is IPropertySymbol prop &&
                prop.DeclaredAccessibility == Accessibility.Public &&
                !prop.IsStatic)
            {
                queue.Enqueue(prop.Type);
            }
        }
    }
    
    return result;
}
```

### 수집 예시

```
FastJson.Serialize(user) 발견
→ User 분석
  ├── Id (int) → primitive, 스킵
  ├── Name (string) → primitive, 스킵
  ├── Address → 등록
  │   ├── City (string) → 스킵
  │   └── Country → 등록
  │       └── Name (string) → 스킵
  └── List<Order> → 등록
      └── Order → 등록
          ├── Id (int) → 스킵
          └── Product → 등록
              └── Name (string) → 스킵

총 등록: User, Address, Country, Order, Product (5개)
```

---

## 성능

### 런타임 성능

```
직접 [JsonSerializable] 작성  →  생성된 코드 A
FastJson 자동 생성            →  생성된 코드 A (동일)

런타임 속도: 완전히 동일 ✅
```

### 빌드 시간

```
직접 작성: [컴파일] → [완료]
FastJson:  [컴파일] → [FastJson Generator] → [완료]
                            +10~50ms

빌드 시간: 미미하게 증가 (체감 안 됨)
```

### 타입 분석 부하

| 타입 수 | 예상 시간 |
|---------|-----------|
| 10개 | ~1ms |
| 100개 | ~10ms |
| 1,000개 | ~100ms |

- `IIncrementalGenerator` 캐싱으로 재빌드 시 거의 0ms
- 순환 참조 방지로 무한 루프 없음

---

## 구현 로드맵

### Phase 1: MVP (2-3주)

- [ ] 기본 타입 (primitive, string)
- [ ] 단순 클래스 (기본 생성자)
- [ ] `List<T>`, `T[]`
- [ ] `[JsonPropertyName]`, `[JsonIgnore]`
- [ ] Serialize만 (Deserialize는 다음 단계)

### Phase 2: Core (2주)

- [ ] Deserialize 구현
- [ ] 매개변수 생성자 / record
- [ ] `Dictionary<K,V>`
- [ ] `Nullable<T>`, `Enum`
- [ ] `DateTime`, `Guid` 등

### Phase 3: Complete (2주)

- [ ] `[JsonConstructor]`, `[JsonInclude]`
- [ ] `[JsonConverter]` 지원
- [ ] 상속 / 다형성
- [ ] init-only, required 프로퍼티
- [ ] Analyzer 강화

### Phase 4: Polish (1주)

- [ ] 성능 최적화
- [ ] 문서화
- [ ] NuGet 배포

**총 예상: 7-8주**

---

## NuGet 패키지 설정

### FastJson.Generator.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <LangVersion>latest</LangVersion>
    <EnforceExtendedAnalyzerRules>true</EnforceExtendedAnalyzerRules>
    <IsRoslynComponent>true</IsRoslynComponent>
    
    <PackageId>FastJson</PackageId>
    <Version>1.0.0</Version>
    <Authors>YourName</Authors>
    <Description>Zero-configuration JSON source generator for AOT</Description>
    <PackageTags>json;source-generator;aot;performance;serialization</PackageTags>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageProjectUrl>https://github.com/yourname/FastJson</PackageProjectUrl>
    <PackageReadmeFile>README.md</PackageReadmeFile>
    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" 
                      Version="4.0.1" 
                      PrivateAssets="all" />
  </ItemGroup>

  <ItemGroup>
    <None Include="README.md" Pack="true" PackagePath="" />
    <None Include="$(OutputPath)\$(AssemblyName).dll" 
          Pack="true" 
          PackagePath="analyzers/dotnet/cs" 
          Visible="false" />
  </ItemGroup>
</Project>
```

### 배포

```bash
dotnet pack -c Release
dotnet nuget push bin/Release/FastJson.1.0.0.nupkg \
  --api-key YOUR_API_KEY \
  --source https://api.nuget.org/v3/index.json
```

---

## 기존 솔루션 비교

| 방식 | DTO 100개 작업량 | 완전 자동 | AOT 지원 |
|------|-----------------|----------|----------|
| System.Text.Json (Reflection) | 없음 | ✅ | ❌ |
| System.Text.Json (AOT) | `[JsonSerializable]` 100줄 | ❌ | ✅ |
| JsonSrcGen | `[Json]` 100줄 | ❌ | ✅ |
| Chickensoft | `[Meta]` 100줄 | ❌ | ✅ |
| **FastJson** | **없음** | **✅** | **✅** |

---

## 리스크 및 완화

| 리스크 | 완화 방안 |
|--------|----------|
| STJ 내부 API 변경 | JsonMetadataServices (public API)만 사용 |
| 엣지 케이스 버그 | MVP는 80% 케이스만, 미지원은 Analyzer 에러 |
| 구현 복잡도 | 단계별 구현, STJ Generator 코드 참고 |

---

## 결론

| 항목 | 값 |
|------|-----|
| 프로젝트명 | FastJson |
| 목표 | 제로 설정 JSON Source Generator |
| 방식 | STJ Generator 대체 (TypeInfo 직접 생성) |
| 타겟 | .NET 6+ |
| 규모 | 중대형 (7-8주) |
| 가치 | Microsoft 논의 후 5년간 미구현, 최초 구현 |