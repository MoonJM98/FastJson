using System.Linq;
using System.Text;
using FastJson.Generator.Models;

namespace FastJson.Generator;

/// <summary>
/// Generates AOT-compatible source code for FastJson serialization.
/// Creates optimized serializers using direct Utf8JsonWriter calls with JsonEncodedText caching.
/// </summary>
public static class CodeEmitter
{
    public static string EmitContext(EquatableArray<TypeModel> types, FastJsonOptionsModel options)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS8600");
        sb.AppendLine("#pragma warning disable CS8601");
        sb.AppendLine("#pragma warning disable CS8602");
        sb.AppendLine("#pragma warning disable CS8603");
        sb.AppendLine("#pragma warning disable CS8604");
        sb.AppendLine("#pragma warning disable CS8618");
        sb.AppendLine("#pragma warning disable CS8625");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Buffers;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Text.Json.Nodes;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine();
        sb.AppendLine("namespace FastJson;");
        sb.AppendLine();

        // Emit pre-encoded property names
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Pre-encoded property names for zero-allocation serialization.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class FastJsonProps");
        sb.AppendLine("{");
        EmitEncodedPropertyNames(sb, types);
        sb.AppendLine("}");
        sb.AppendLine();

        // Emit helpers if any type uses IgnoreCase or IgnoreSpecialCharacters
        bool needsHelpers = types.Any(t => t.IgnoreCase || t.IgnoreSpecialCharacters);
        if (needsHelpers)
        {
            EmitHelpers(sb);
        }

        // Emit serializers for each type
        foreach (var type in types)
        {
            if (type.IsAbstract)
            {
                EmitAbstractSerializer(sb, type, types);
            }
            else
            {
                EmitSerializer(sb, type, types, options);
            }
            // Skip deserializer for anonymous types (write-only)
            if (!type.IsAnonymous)
            {
                EmitDeserializer(sb, type, types, options);
            }
        }

        // Emit module initializer
        EmitModuleInitializer(sb, types);

        return sb.ToString();
    }

    private static void EmitEncodedPropertyNames(StringBuilder sb, EquatableArray<TypeModel> types)
    {
        var emittedNames = new HashSet<string>();

        foreach (var type in types)
        {
            foreach (var prop in type.Properties)
            {
                if (prop.IsIgnored) continue;
                // Use NamingPolicy-transformed name for serialization
                var jsonName = GetEffectiveJsonName(prop, type);
                var fieldName = GetEncodedPropFieldName(jsonName);
                if (emittedNames.Add(fieldName))
                {
                    sb.AppendLine($"    public static readonly JsonEncodedText {fieldName} = JsonEncodedText.Encode(\"{EscapeString(jsonName)}\");");
                }
            }

            // Add type discriminator property name for polymorphic types
            if (type.IsPolymorphic && type.TypeDiscriminatorPropertyName != null)
            {
                var fieldName = GetEncodedPropFieldName(type.TypeDiscriminatorPropertyName);
                if (emittedNames.Add(fieldName))
                {
                    sb.AppendLine($"    public static readonly JsonEncodedText {fieldName} = JsonEncodedText.Encode(\"{EscapeString(type.TypeDiscriminatorPropertyName)}\");");
                }
            }
        }
    }

    /// <summary>
    /// Gets the effective JSON name for a property, applying NamingPolicy if no explicit [JsonPropertyName] was specified.
    /// </summary>
    private static string GetEffectiveJsonName(PropertyModel prop, TypeModel type)
    {
        // If the property has an explicit [JsonPropertyName], use it as-is
        // We can detect this by checking if jsonName differs from the camelCase version of Name
        // But actually, TypeCollector already applies camelCase by default, so we need a different approach

        // If NamingPolicy is None (0), use the property's jsonName as-is (which is already camelCase or [JsonPropertyName])
        if (type.NamingPolicy == 0)
            return prop.JsonName;

        // If NamingPolicy is CamelCase (1), use the property's jsonName (already camelCase)
        if (type.NamingPolicy == 1)
            return prop.JsonName;

        // For SnakeCase (2) and KebabCase (3), apply transformation to the property Name (PascalCase)
        // This ensures we transform from the original property name, not the already-camelCased version
        return ApplyNamingPolicy(prop.Name, type.NamingPolicy);
    }

    private static string GetEncodedPropFieldName(string jsonName)
    {
        // Create a valid C# identifier from the JSON property name
        var sb = new StringBuilder("_");
        foreach (var c in jsonName)
        {
            if (char.IsLetterOrDigit(c))
                sb.Append(c);
            else
                sb.Append('_');
        }
        return sb.ToString();
    }

    private static void EmitSerializer(StringBuilder sb, TypeModel type, EquatableArray<TypeModel> types, FastJsonOptionsModel options)
    {
        var safeTypeName = GetSafeTypeName(type);
        sb.AppendLine($"internal static class {safeTypeName}Serializer");
        sb.AppendLine("{");

        if (type.IsCollection)
        {
            EmitCollectionWriter(sb, type, types);
        }
        else if (type.IsEnum)
        {
            EmitEnumWriter(sb, type);
        }
        else
        {
            EmitObjectWriter(sb, type, types);
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitAbstractSerializer(StringBuilder sb, TypeModel type, EquatableArray<TypeModel> types)
    {
        var safeTypeName = GetSafeTypeName(type);
        sb.AppendLine($"internal static class {safeTypeName}Serializer");
        sb.AppendLine("{");
        sb.AppendLine($"    public static void Write(Utf8JsonWriter w, {type.FullyQualifiedName} v)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (v is null) { w.WriteNullValue(); return; }");

        if (type.IsPolymorphic && type.DerivedTypes.Length > 0)
        {
            foreach (var derived in type.DerivedTypes)
            {
                var derivedSafeTypeName = GetSafeTypeNameFromFqn(derived.TypeFullyQualifiedName);
                sb.AppendLine($"        if (v is {derived.TypeFullyQualifiedName} {derivedSafeTypeName.ToLower()})");
                sb.AppendLine("        {");
                sb.AppendLine($"            {derivedSafeTypeName}Serializer.Write(w, {derivedSafeTypeName.ToLower()});");
                sb.AppendLine("            return;");
                sb.AppendLine("        }");
            }
        }

        sb.AppendLine($"        throw new InvalidOperationException($\"Unknown derived type: {{v.GetType()}}\");");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitObjectWriter(StringBuilder sb, TypeModel type, EquatableArray<TypeModel> types)
    {
        sb.AppendLine($"    public static void Write(Utf8JsonWriter w, {type.FullyQualifiedName} v)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (v is null) { w.WriteNullValue(); return; }");

        // Handle polymorphic types
        if (type.IsPolymorphic && type.DerivedTypes.Length > 0)
        {
            foreach (var derived in type.DerivedTypes)
            {
                var derivedSafeTypeName = GetSafeTypeNameFromFqn(derived.TypeFullyQualifiedName);
                sb.AppendLine($"        if (v is {derived.TypeFullyQualifiedName} {derivedSafeTypeName.ToLower()})");
                sb.AppendLine("        {");
                sb.AppendLine($"            {derivedSafeTypeName}Serializer.Write(w, {derivedSafeTypeName.ToLower()});");
                sb.AppendLine("            return;");
                sb.AppendLine("        }");
            }
        }

        sb.AppendLine("        w.WriteStartObject();");

        // Write type discriminator for derived types of polymorphic base
        // (The derived type serializer handles the discriminator)
        foreach (var baseType in types)
        {
            if (baseType.IsPolymorphic)
            {
                foreach (var derived in baseType.DerivedTypes)
                {
                    if (derived.TypeFullyQualifiedName == type.FullyQualifiedName && derived.TypeDiscriminator != null)
                    {
                        var discFieldName = GetEncodedPropFieldName(baseType.TypeDiscriminatorPropertyName ?? "$type");
                        if (derived.IsStringDiscriminator)
                        {
                            sb.AppendLine($"        w.WriteString(FastJsonProps.{discFieldName}, \"{EscapeString(derived.TypeDiscriminator)}\");");
                        }
                        else
                        {
                            sb.AppendLine($"        w.WriteNumber(FastJsonProps.{discFieldName}, {derived.TypeDiscriminator});");
                        }
                    }
                }
            }
        }

        foreach (var prop in type.Properties)
        {
            if (prop.IsIgnored || !prop.HasGetter) continue;

            var effectiveJsonName = GetEffectiveJsonName(prop, type);
            var encodedName = $"FastJsonProps.{GetEncodedPropFieldName(effectiveJsonName)}";
            var access = $"v.{prop.Name}";

            // Handle nullable reference types
            if (prop.IsNullable && !prop.IsValueType)
            {
                sb.AppendLine($"        if ({access} is not null)");
                sb.AppendLine("        {");
                EmitPropertyWrite(sb, prop, encodedName, access, types, "            ");
                sb.AppendLine("        }");
            }
            else
            {
                EmitPropertyWrite(sb, prop, encodedName, access, types, "        ");
            }
        }

        sb.AppendLine("        w.WriteEndObject();");
        sb.AppendLine("    }");
    }

    private static void EmitPropertyWrite(StringBuilder sb, PropertyModel prop, string encodedName, string access, EquatableArray<TypeModel> types, string indent)
    {
        var typeName = prop.TypeFullyQualifiedName;

        // Handle Nullable<T>
        if (typeName.StartsWith("global::System.Nullable<") || typeName.StartsWith("System.Nullable<"))
        {
            // Extract inner type
            var innerStart = typeName.IndexOf('<') + 1;
            var innerEnd = typeName.LastIndexOf('>');
            var innerType = typeName.Substring(innerStart, innerEnd - innerStart);

            sb.AppendLine($"{indent}if ({access}.HasValue)");
            sb.AppendLine($"{indent}{{");
            EmitPrimitiveWrite(sb, innerType, encodedName, $"{access}.Value", $"{indent}    ");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine($"{indent}else");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    w.WriteNull({encodedName});");
            sb.AppendLine($"{indent}}}");
            return;
        }

        // Primitives - direct writer calls
        if (TryEmitPrimitiveWrite(sb, typeName, encodedName, access, indent))
        {
            return;
        }

        // Known registered types
        foreach (var knownType in types)
        {
            if (knownType.FullyQualifiedName == typeName)
            {
                var safeTypeName = GetSafeTypeName(knownType);
                sb.AppendLine($"{indent}w.WritePropertyName({encodedName});");
                sb.AppendLine($"{indent}{safeTypeName}Serializer.Write(w, {access});");
                return;
            }
        }

        // Handle JsonNode, JsonObject, JsonArray, JsonValue types
        if (IsJsonNodeType(typeName))
        {
            sb.AppendLine($"{indent}w.WritePropertyName({encodedName});");
            sb.AppendLine($"{indent}if ({access} is not null)");
            sb.AppendLine($"{indent}    {access}.WriteTo(w);");
            sb.AppendLine($"{indent}else");
            sb.AppendLine($"{indent}    w.WriteNullValue();");
            return;
        }

        // Fallback - use JsonSerializer with default options
        sb.AppendLine($"{indent}w.WritePropertyName({encodedName});");
        sb.AppendLine($"{indent}JsonSerializer.Serialize(w, {access});");
    }

    private static bool IsJsonNodeType(string typeName)
    {
        var normalized = typeName;
        if (normalized.StartsWith("global::"))
            normalized = normalized.Substring(8);

        return normalized == "System.Text.Json.Nodes.JsonNode" ||
               normalized == "System.Text.Json.Nodes.JsonObject" ||
               normalized == "System.Text.Json.Nodes.JsonArray" ||
               normalized == "System.Text.Json.Nodes.JsonValue";
    }

    private static bool TryEmitPrimitiveWrite(StringBuilder sb, string typeName, string encodedName, string access, string indent)
    {
        switch (NormalizeTypeName(typeName))
        {
            case "string":
                sb.AppendLine($"{indent}w.WriteString({encodedName}, {access});");
                return true;
            case "int":
            case "long":
            case "short":
            case "byte":
            case "uint":
            case "ulong":
            case "ushort":
            case "sbyte":
            case "double":
            case "float":
            case "decimal":
                sb.AppendLine($"{indent}w.WriteNumber({encodedName}, {access});");
                return true;
            case "bool":
                sb.AppendLine($"{indent}w.WriteBoolean({encodedName}, {access});");
                return true;
            case "System.DateTime":
            case "System.DateTimeOffset":
            case "System.Guid":
            case "System.DateOnly":
            case "System.TimeOnly":
                sb.AppendLine($"{indent}w.WriteString({encodedName}, {access});");
                return true;
            case "System.TimeSpan":
                sb.AppendLine($"{indent}w.WriteString({encodedName}, {access}.ToString());");
                return true;
        }
        return false;
    }

    private static void EmitPrimitiveWrite(StringBuilder sb, string typeName, string encodedName, string access, string indent)
    {
        switch (NormalizeTypeName(typeName))
        {
            case "string":
                sb.AppendLine($"{indent}w.WriteString({encodedName}, {access});");
                break;
            case "int":
            case "long":
            case "short":
            case "byte":
            case "uint":
            case "ulong":
            case "ushort":
            case "sbyte":
            case "double":
            case "float":
            case "decimal":
                sb.AppendLine($"{indent}w.WriteNumber({encodedName}, {access});");
                break;
            case "bool":
                sb.AppendLine($"{indent}w.WriteBoolean({encodedName}, {access});");
                break;
            case "System.DateTime":
            case "System.DateTimeOffset":
            case "System.Guid":
            case "System.DateOnly":
            case "System.TimeOnly":
                sb.AppendLine($"{indent}w.WriteString({encodedName}, {access});");
                break;
            case "System.TimeSpan":
                sb.AppendLine($"{indent}w.WriteString({encodedName}, {access}.ToString());");
                break;
        }
    }

    private static void EmitPrimitiveValueWrite(StringBuilder sb, string typeName, string access, string indent)
    {
        switch (NormalizeTypeName(typeName))
        {
            case "string":
                sb.AppendLine($"{indent}w.WriteStringValue({access});");
                break;
            case "int":
            case "long":
            case "short":
            case "byte":
            case "uint":
            case "ulong":
            case "ushort":
            case "sbyte":
            case "double":
            case "float":
            case "decimal":
                sb.AppendLine($"{indent}w.WriteNumberValue({access});");
                break;
            case "bool":
                sb.AppendLine($"{indent}w.WriteBooleanValue({access});");
                break;
            case "System.DateTime":
            case "System.DateTimeOffset":
            case "System.Guid":
            case "System.DateOnly":
            case "System.TimeOnly":
                sb.AppendLine($"{indent}w.WriteStringValue({access});");
                break;
            case "System.TimeSpan":
                sb.AppendLine($"{indent}w.WriteStringValue({access}.ToString());");
                break;
        }
    }

    private static void EmitCollectionWriter(StringBuilder sb, TypeModel type, EquatableArray<TypeModel> types)
    {
        sb.AppendLine($"    public static void Write(Utf8JsonWriter w, {type.FullyQualifiedName} v)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (v is null) { w.WriteNullValue(); return; }");

        if (type.KeyTypeName != null && type.ValueTypeName != null)
        {
            // Dictionary
            sb.AppendLine("        w.WriteStartObject();");
            sb.AppendLine("        foreach (var kvp in v)");
            sb.AppendLine("        {");
            sb.AppendLine("            w.WritePropertyName(kvp.Key.ToString()!);");
            EmitValueWrite(sb, type.ValueTypeName, "kvp.Value", types, "            ");
            sb.AppendLine("        }");
            sb.AppendLine("        w.WriteEndObject();");
        }
        else if (type.ElementTypeName != null)
        {
            // List/Array
            sb.AppendLine("        w.WriteStartArray();");
            sb.AppendLine("        foreach (var item in v)");
            sb.AppendLine("        {");
            EmitValueWrite(sb, type.ElementTypeName, "item", types, "            ");
            sb.AppendLine("        }");
            sb.AppendLine("        w.WriteEndArray();");
        }

        sb.AppendLine("    }");
    }

    private static void EmitValueWrite(StringBuilder sb, string typeName, string access, EquatableArray<TypeModel> types, string indent)
    {
        // Check if value type (no null check needed)
        bool isValueType = IsValueTypeName(typeName);

        // Handle null only for reference types
        if (!isValueType)
        {
            sb.AppendLine($"{indent}if ({access} is null) {{ w.WriteNullValue(); continue; }}");
        }

        // Primitives
        switch (NormalizeTypeName(typeName))
        {
            case "string":
                sb.AppendLine($"{indent}w.WriteStringValue({access});");
                return;
            case "int":
            case "long":
            case "short":
            case "byte":
            case "uint":
            case "ulong":
            case "ushort":
            case "sbyte":
            case "double":
            case "float":
            case "decimal":
                sb.AppendLine($"{indent}w.WriteNumberValue({access});");
                return;
            case "bool":
                sb.AppendLine($"{indent}w.WriteBooleanValue({access});");
                return;
            case "System.DateTime":
            case "System.DateTimeOffset":
            case "System.Guid":
            case "System.DateOnly":
            case "System.TimeOnly":
                sb.AppendLine($"{indent}w.WriteStringValue({access});");
                return;
            case "System.TimeSpan":
                sb.AppendLine($"{indent}w.WriteStringValue({access}.ToString());");
                return;
        }

        // Known registered types
        foreach (var knownType in types)
        {
            if (knownType.FullyQualifiedName == typeName)
            {
                var safeTypeName = GetSafeTypeName(knownType);
                sb.AppendLine($"{indent}{safeTypeName}Serializer.Write(w, {access});");
                return;
            }
        }

        // Fallback
        sb.AppendLine($"{indent}JsonSerializer.Serialize(w, {access});");
    }

    private static void EmitEnumWriter(StringBuilder sb, TypeModel type)
    {
        sb.AppendLine($"    public static void Write(Utf8JsonWriter w, {type.FullyQualifiedName} v)");
        sb.AppendLine("    {");

        // Check if enum has JsonStringEnumConverter
        if (type.ConverterTypeName != null && type.ConverterTypeName.Contains("JsonStringEnumConverter"))
        {
            sb.AppendLine("        w.WriteStringValue(v.ToString());");
        }
        else
        {
            sb.AppendLine($"        w.WriteNumberValue((int)v);");
        }

        sb.AppendLine("    }");
    }

    private static void EmitDeserializer(StringBuilder sb, TypeModel type, EquatableArray<TypeModel> types, FastJsonOptionsModel options)
    {
        var safeTypeName = GetSafeTypeName(type);
        sb.AppendLine($"internal static class {safeTypeName}Deserializer");
        sb.AppendLine("{");

        if (type.IsCollection)
        {
            EmitCollectionReader(sb, type, types);
        }
        else if (type.IsEnum)
        {
            EmitEnumReader(sb, type);
        }
        else if (type.IsAbstract)
        {
            EmitAbstractReader(sb, type, types);
        }
        else
        {
            EmitObjectReader(sb, type, types);
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitObjectReader(StringBuilder sb, TypeModel type, EquatableArray<TypeModel> types)
    {
        sb.AppendLine($"    public static {type.FullyQualifiedName}? Read(ref Utf8JsonReader r)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (r.TokenType == JsonTokenType.Null) { r.Read(); return default; }");
        sb.AppendLine("        if (r.TokenType != JsonTokenType.StartObject) r.Read();");
        sb.AppendLine("        if (r.TokenType == JsonTokenType.Null) return default;");
        sb.AppendLine("        if (r.TokenType != JsonTokenType.StartObject) throw new JsonException($\"Expected StartObject, got {r.TokenType}\");");
        sb.AppendLine();

        // Check if we use constructor parameters
        bool useParameterizedCtor = type.ConstructorParameters.Length > 0 && !type.HasParameterlessConstructor;

        // Generate local variables for properties with setters
        var visibleProps = type.Properties.Where(p => !p.IsIgnored && p.HasSetter).ToList();

        // Also collect constructor parameters (for types that need them)
        var ctorParams = new Dictionary<string, ConstructorParameterModel>();
        if (useParameterizedCtor)
        {
            foreach (var param in type.ConstructorParameters)
            {
                ctorParams[param.JsonName.ToLowerInvariant()] = param;
            }
        }

        // Emit local variables for settable properties
        foreach (var prop in visibleProps)
        {
            var defaultValue = GetDefaultValue(prop.TypeFullyQualifiedName, prop.IsNullable);
            sb.AppendLine($"        {prop.TypeFullyQualifiedName} __{prop.Name} = {defaultValue};");
        }

        // Emit local variables for constructor parameters (if not already covered by a property)
        if (useParameterizedCtor)
        {
            foreach (var param in type.ConstructorParameters)
            {
                // Check if there's already a property with this name
                bool hasProp = visibleProps.Any(p => string.Equals(p.Name, param.Name, StringComparison.OrdinalIgnoreCase));
                if (!hasProp)
                {
                    var defaultValue = GetDefaultValue(param.TypeFullyQualifiedName, true);
                    sb.AppendLine($"        {param.TypeFullyQualifiedName} __{param.Name} = {defaultValue};");
                }
            }
        }
        sb.AppendLine();

        sb.AppendLine("        while (r.Read() && r.TokenType != JsonTokenType.EndObject)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (r.TokenType != JsonTokenType.PropertyName) continue;");
        sb.AppendLine("            var propName = r.GetString();");
        sb.AppendLine("            r.Read();");
        sb.AppendLine();

        // Use flexible matching if IgnoreCase or IgnoreSpecialCharacters is enabled
        if (type.IgnoreCase || type.IgnoreSpecialCharacters)
        {
            EmitFlexiblePropertyMatching(sb, type, visibleProps, useParameterizedCtor, types);
        }
        else
        {
            // Use standard switch statement for exact matching
            sb.AppendLine("            switch (propName)");
            sb.AppendLine("            {");

            // Emit cases for properties with setters
            foreach (var prop in visibleProps)
            {
                var effectiveJsonName = GetEffectiveJsonName(prop, type);
                sb.AppendLine($"                case \"{effectiveJsonName}\":");
                EmitPropertyRead(sb, prop, types, "                    ");
                sb.AppendLine("                    break;");
            }

            // Emit cases for constructor parameters (if not already covered by a property)
            if (useParameterizedCtor)
            {
                foreach (var param in type.ConstructorParameters)
                {
                    bool hasProp = visibleProps.Any(p => string.Equals(p.JsonName, param.JsonName, StringComparison.OrdinalIgnoreCase));
                    if (!hasProp)
                    {
                        sb.AppendLine($"                case \"{param.JsonName}\":");
                        EmitCtorParamRead(sb, param, types, "                    ");
                        sb.AppendLine("                    break;");
                    }
                }
            }

            sb.AppendLine("                default:");
            sb.AppendLine("                    r.Skip();");
            sb.AppendLine("                    break;");
            sb.AppendLine("            }");
        }
        sb.AppendLine("        }");
        sb.AppendLine();

        // Construct object
        if (useParameterizedCtor)
        {
            // Use parameterized constructor
            var args = string.Join(", ", type.ConstructorParameters.Select(p =>
            {
                // Find matching property by name (case-insensitive)
                foreach (var prop in visibleProps)
                {
                    if (string.Equals(prop.Name, p.Name, StringComparison.OrdinalIgnoreCase))
                    {
                        return $"__{prop.Name}";
                    }
                }
                // Use the constructor param variable
                return $"__{p.Name}";
            }));
            sb.AppendLine($"        return new {type.FullyQualifiedName}({args});");
        }
        else
        {
            // Use object initializer
            sb.AppendLine($"        return new {type.FullyQualifiedName}");
            sb.AppendLine("        {");
            foreach (var prop in visibleProps)
            {
                sb.AppendLine($"            {prop.Name} = __{prop.Name},");
            }
            sb.AppendLine("        };");
        }

        sb.AppendLine("    }");
    }

    private static void EmitCtorParamRead(StringBuilder sb, ConstructorParameterModel param, EquatableArray<TypeModel> types, string indent)
    {
        var varName = $"__{param.Name}";
        var typeName = param.TypeFullyQualifiedName;

        // Handle null
        sb.AppendLine($"{indent}if (r.TokenType == JsonTokenType.Null) {{ {varName} = default; }}");

        // Handle Nullable<T>
        if (typeName.StartsWith("global::System.Nullable<") || typeName.StartsWith("System.Nullable<"))
        {
            var innerStart = typeName.IndexOf('<') + 1;
            var innerEnd = typeName.LastIndexOf('>');
            var innerType = typeName.Substring(innerStart, innerEnd - innerStart);

            var primitiveRead = GetPrimitiveRead(innerType);
            if (primitiveRead != null)
            {
                sb.AppendLine($"{indent}else {varName} = {primitiveRead};");
            }
            else
            {
                sb.AppendLine($"{indent}else {varName} = JsonSerializer.Deserialize<{typeName}>(ref r);");
            }
            return;
        }

        // Primitives
        var primRead = GetPrimitiveRead(typeName);
        if (primRead != null)
        {
            sb.AppendLine($"{indent}else {varName} = {primRead};");
            return;
        }

        // Known registered types
        foreach (var knownType in types)
        {
            if (knownType.FullyQualifiedName == typeName)
            {
                var safeTypeName = GetSafeTypeName(knownType);
                sb.AppendLine($"{indent}else {varName} = {safeTypeName}Deserializer.Read(ref r);");
                return;
            }
        }

        // Fallback
        sb.AppendLine($"{indent}else {varName} = JsonSerializer.Deserialize<{typeName}>(ref r);");
    }

    private static void EmitPropertyRead(StringBuilder sb, PropertyModel prop, EquatableArray<TypeModel> types, string indent)
    {
        var varName = $"__{prop.Name}";
        var typeName = prop.TypeFullyQualifiedName;

        // Check if property allows reading numbers from strings
        // JsonNumberHandling.AllowReadingFromString = 0x1 = 1 (bit flag)
        // JsonNumberHandling.WriteAsString = 0x2 = 2
        bool allowReadFromString = false;
        if (prop.NumberHandling != null)
        {
            // Extract the numeric value from the end of the string like "(global::...JsonNumberHandling)1"
            var nh = prop.NumberHandling;
            var lastParen = nh.LastIndexOf(')');
            if (lastParen >= 0 && lastParen < nh.Length - 1)
            {
                var numStr = nh.Substring(lastParen + 1);
                if (int.TryParse(numStr, out var numValue))
                {
                    // Check if AllowReadingFromString bit (1) is set
                    allowReadFromString = (numValue & 1) != 0;
                }
            }
        }

        // Handle null
        sb.AppendLine($"{indent}if (r.TokenType == JsonTokenType.Null) {{ {varName} = default; }}");

        // Handle Nullable<T>
        if (typeName.StartsWith("global::System.Nullable<") || typeName.StartsWith("System.Nullable<"))
        {
            var innerStart = typeName.IndexOf('<') + 1;
            var innerEnd = typeName.LastIndexOf('>');
            var innerType = typeName.Substring(innerStart, innerEnd - innerStart);

            var primRead = GetPrimitiveRead(innerType);
            if (allowReadFromString && IsNumericType(innerType))
            {
                sb.AppendLine($"{indent}else if (r.TokenType == JsonTokenType.String) {varName} = {GetNumberFromStringRead(innerType)};");
                sb.AppendLine($"{indent}else {varName} = {primRead};");
            }
            else
            {
                sb.AppendLine($"{indent}else {varName} = {primRead};");
            }
            return;
        }

        // Primitives
        var primitiveRead = GetPrimitiveRead(typeName);
        if (primitiveRead != null)
        {
            if (allowReadFromString && IsNumericType(typeName))
            {
                sb.AppendLine($"{indent}else if (r.TokenType == JsonTokenType.String) {varName} = {GetNumberFromStringRead(typeName)};");
                sb.AppendLine($"{indent}else {varName} = {primitiveRead};");
            }
            else
            {
                sb.AppendLine($"{indent}else {varName} = {primitiveRead};");
            }
            return;
        }

        // Known registered types
        foreach (var knownType in types)
        {
            if (knownType.FullyQualifiedName == typeName)
            {
                var safeTypeName = GetSafeTypeName(knownType);
                sb.AppendLine($"{indent}else {varName} = {safeTypeName}Deserializer.Read(ref r);");
                return;
            }
        }

        // Handle JsonNode, JsonObject, JsonArray, JsonValue types
        if (IsJsonNodeType(typeName))
        {
            sb.AppendLine($"{indent}else {varName} = System.Text.Json.Nodes.JsonNode.Parse(ref r);");
            return;
        }

        // Fallback
        sb.AppendLine($"{indent}else {varName} = JsonSerializer.Deserialize<{typeName}>(ref r);");
    }

    private static bool IsNumericType(string typeName)
    {
        return NormalizeTypeName(typeName) switch
        {
            "int" or "long" or "short" or "byte" or "sbyte" or
            "uint" or "ulong" or "ushort" or
            "double" or "float" or "decimal" => true,
            _ => false
        };
    }

    private static string GetNumberFromStringRead(string typeName)
    {
        return NormalizeTypeName(typeName) switch
        {
            "int" => "int.Parse(r.GetString()!)",
            "long" => "long.Parse(r.GetString()!)",
            "short" => "short.Parse(r.GetString()!)",
            "byte" => "byte.Parse(r.GetString()!)",
            "sbyte" => "sbyte.Parse(r.GetString()!)",
            "uint" => "uint.Parse(r.GetString()!)",
            "ulong" => "ulong.Parse(r.GetString()!)",
            "ushort" => "ushort.Parse(r.GetString()!)",
            "double" => "double.Parse(r.GetString()!)",
            "float" => "float.Parse(r.GetString()!)",
            "decimal" => "decimal.Parse(r.GetString()!)",
            _ => "0"
        };
    }

    private static string? GetPrimitiveRead(string typeName)
    {
        return NormalizeTypeName(typeName) switch
        {
            "string" => "r.GetString()",
            "int" => "r.GetInt32()",
            "long" => "r.GetInt64()",
            "short" => "r.GetInt16()",
            "byte" => "r.GetByte()",
            "sbyte" => "r.GetSByte()",
            "uint" => "r.GetUInt32()",
            "ulong" => "r.GetUInt64()",
            "ushort" => "r.GetUInt16()",
            "double" => "r.GetDouble()",
            "float" => "r.GetSingle()",
            "decimal" => "r.GetDecimal()",
            "bool" => "r.GetBoolean()",
            "System.DateTime" => "r.GetDateTime()",
            "System.DateTimeOffset" => "r.GetDateTimeOffset()",
            "System.Guid" => "r.GetGuid()",
            _ => null
        };
    }

    private static void EmitCollectionReader(StringBuilder sb, TypeModel type, EquatableArray<TypeModel> types)
    {
        sb.AppendLine($"    public static {type.FullyQualifiedName}? Read(ref Utf8JsonReader r)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (r.TokenType == JsonTokenType.Null) { r.Read(); return default; }");
        sb.AppendLine("        if (r.TokenType != JsonTokenType.StartArray && r.TokenType != JsonTokenType.StartObject) r.Read();");
        sb.AppendLine("        if (r.TokenType == JsonTokenType.Null) return default;");

        if (type.KeyTypeName != null && type.ValueTypeName != null)
        {
            // Dictionary
            sb.AppendLine("        if (r.TokenType != JsonTokenType.StartObject) throw new JsonException($\"Expected StartObject for dictionary, got {r.TokenType}\");");
            sb.AppendLine($"        var result = new {type.FullyQualifiedName}();");
            sb.AppendLine("        while (r.Read() && r.TokenType != JsonTokenType.EndObject)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (r.TokenType != JsonTokenType.PropertyName) continue;");
            sb.AppendLine($"            var key = {GetKeyRead(type.KeyTypeName)};");
            sb.AppendLine("            r.Read();");
            EmitValueRead(sb, type.ValueTypeName, "value", types, "            ");
            sb.AppendLine("            result[key] = value;");
            sb.AppendLine("        }");
            sb.AppendLine("        return result;");
        }
        else if (type.ElementTypeName != null)
        {
            // List/Array
            sb.AppendLine("        if (r.TokenType != JsonTokenType.StartArray) throw new JsonException($\"Expected StartArray, got {r.TokenType}\");");

            if (type.FullyQualifiedName.EndsWith("[]"))
            {
                // Array
                sb.AppendLine($"        var list = new List<{type.ElementTypeName}>();");
                sb.AppendLine("        while (r.Read() && r.TokenType != JsonTokenType.EndArray)");
                sb.AppendLine("        {");
                EmitValueRead(sb, type.ElementTypeName, "item", types, "            ");
                sb.AppendLine("            list.Add(item);");
                sb.AppendLine("        }");
                sb.AppendLine("        return list.ToArray();");
            }
            else
            {
                // List
                sb.AppendLine($"        var result = new {type.FullyQualifiedName}();");
                sb.AppendLine("        while (r.Read() && r.TokenType != JsonTokenType.EndArray)");
                sb.AppendLine("        {");
                EmitValueRead(sb, type.ElementTypeName, "item", types, "            ");
                sb.AppendLine("            result.Add(item);");
                sb.AppendLine("        }");
                sb.AppendLine("        return result;");
            }
        }

        sb.AppendLine("    }");
    }

    private static string GetKeyRead(string typeName)
    {
        return NormalizeTypeName(typeName) switch
        {
            "string" => "r.GetString()!",
            "int" => "int.Parse(r.GetString()!)",
            "long" => "long.Parse(r.GetString()!)",
            "System.Guid" => "Guid.Parse(r.GetString()!)",
            _ => "r.GetString()!"
        };
    }

    private static void EmitValueRead(StringBuilder sb, string typeName, string varName, EquatableArray<TypeModel> types, string indent)
    {
        sb.AppendLine($"{indent}{typeName} {varName};");
        sb.AppendLine($"{indent}if (r.TokenType == JsonTokenType.Null) {{ {varName} = default!; }}");

        var primitiveRead = GetPrimitiveRead(typeName);
        if (primitiveRead != null)
        {
            sb.AppendLine($"{indent}else {{ {varName} = {primitiveRead}!; }}");
            return;
        }

        // Known registered types
        foreach (var knownType in types)
        {
            if (knownType.FullyQualifiedName == typeName)
            {
                var safeTypeName = GetSafeTypeName(knownType);
                sb.AppendLine($"{indent}else {{ {varName} = {safeTypeName}Deserializer.Read(ref r)!; }}");
                return;
            }
        }

        sb.AppendLine($"{indent}else {{ {varName} = JsonSerializer.Deserialize<{typeName}>(ref r)!; }}");
    }

    private static void EmitEnumReader(StringBuilder sb, TypeModel type)
    {
        sb.AppendLine($"    public static {type.FullyQualifiedName} Read(ref Utf8JsonReader r)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (r.TokenType != JsonTokenType.String && r.TokenType != JsonTokenType.Number) r.Read();");

        if (type.ConverterTypeName != null && type.ConverterTypeName.Contains("JsonStringEnumConverter"))
        {
            sb.AppendLine($"        if (r.TokenType == JsonTokenType.String) return Enum.Parse<{type.FullyQualifiedName}>(r.GetString()!);");
            sb.AppendLine($"        return ({type.FullyQualifiedName})r.GetInt32();");
        }
        else
        {
            sb.AppendLine($"        if (r.TokenType == JsonTokenType.Number) return ({type.FullyQualifiedName})r.GetInt32();");
            sb.AppendLine($"        return Enum.Parse<{type.FullyQualifiedName}>(r.GetString()!);");
        }

        sb.AppendLine("    }");
    }

    private static void EmitAbstractReader(StringBuilder sb, TypeModel type, EquatableArray<TypeModel> types)
    {
        sb.AppendLine($"    public static {type.FullyQualifiedName}? Read(ref Utf8JsonReader r)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (r.TokenType == JsonTokenType.Null) { r.Read(); return default; }");
        sb.AppendLine("        if (r.TokenType != JsonTokenType.StartObject) r.Read();");
        sb.AppendLine("        if (r.TokenType == JsonTokenType.Null) return default;");
        sb.AppendLine("        if (r.TokenType != JsonTokenType.StartObject) throw new JsonException($\"Expected StartObject, got {r.TokenType}\");");
        sb.AppendLine();

        if (type.IsPolymorphic && type.DerivedTypes.Length > 0)
        {
            var discPropName = type.TypeDiscriminatorPropertyName ?? "$type";

            // Clone reader to peek at type discriminator
            sb.AppendLine("        var readerCopy = r;");
            sb.AppendLine("        string? typeDiscriminator = null;");
            sb.AppendLine("        while (readerCopy.Read() && readerCopy.TokenType != JsonTokenType.EndObject)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (readerCopy.TokenType == JsonTokenType.PropertyName)");
            sb.AppendLine("            {");
            sb.AppendLine($"                if (readerCopy.GetString() == \"{discPropName}\")");
            sb.AppendLine("                {");
            sb.AppendLine("                    readerCopy.Read();");
            sb.AppendLine("                    typeDiscriminator = readerCopy.TokenType == JsonTokenType.String ? readerCopy.GetString() : readerCopy.GetInt32().ToString();");
            sb.AppendLine("                    break;");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine("            readerCopy.Skip();");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        return typeDiscriminator switch");
            sb.AppendLine("        {");

            foreach (var derived in type.DerivedTypes)
            {
                var derivedSafeTypeName = GetSafeTypeNameFromFqn(derived.TypeFullyQualifiedName);
                var disc = derived.TypeDiscriminator ?? derivedSafeTypeName;
                sb.AppendLine($"            \"{disc}\" => {derivedSafeTypeName}Deserializer.Read(ref r),");
            }

            sb.AppendLine($"            _ => throw new JsonException($\"Unknown type discriminator: {{typeDiscriminator}}\"),");
            sb.AppendLine("        };");
        }
        else
        {
            sb.AppendLine($"        throw new JsonException(\"Cannot deserialize abstract type {type.FullyQualifiedName}\");");
        }

        sb.AppendLine("    }");
    }

    private static void EmitFlexiblePropertyMatching(
        StringBuilder sb,
        TypeModel type,
        List<PropertyModel> visibleProps,
        bool useParameterizedCtor,
        EquatableArray<TypeModel> types)
    {
        bool isFirst = true;

        // Emit if-else chain for properties with setters
        foreach (var prop in visibleProps)
        {
            var effectiveJsonName = GetEffectiveJsonName(prop, type);
            string condition;

            if (type.IgnoreSpecialCharacters)
            {
                // Use normalized comparison (ignores case and special characters)
                var normalizedTarget = NormalizeForComparison(effectiveJsonName);
                condition = $"FastJsonHelpers.EqualsNormalized(propName, \"{normalizedTarget}\")";
            }
            else if (type.IgnoreCase)
            {
                // Use case-insensitive comparison
                condition = $"FastJsonHelpers.EqualsIgnoreCase(propName, \"{effectiveJsonName}\")";
            }
            else
            {
                // Should not happen, but fallback to exact match
                condition = $"propName == \"{effectiveJsonName}\"";
            }

            if (isFirst)
            {
                sb.AppendLine($"            if ({condition})");
                isFirst = false;
            }
            else
            {
                sb.AppendLine($"            else if ({condition})");
            }

            sb.AppendLine("            {");
            EmitPropertyRead(sb, prop, types, "                ");
            sb.AppendLine("            }");
        }

        // Emit cases for constructor parameters (if not already covered by a property)
        if (useParameterizedCtor)
        {
            foreach (var param in type.ConstructorParameters)
            {
                bool hasProp = visibleProps.Any(p => string.Equals(p.JsonName, param.JsonName, StringComparison.OrdinalIgnoreCase));
                if (!hasProp)
                {
                    string condition;
                    if (type.IgnoreSpecialCharacters)
                    {
                        var normalizedTarget = NormalizeForComparison(param.JsonName);
                        condition = $"FastJsonHelpers.EqualsNormalized(propName, \"{normalizedTarget}\")";
                    }
                    else if (type.IgnoreCase)
                    {
                        condition = $"FastJsonHelpers.EqualsIgnoreCase(propName, \"{param.JsonName}\")";
                    }
                    else
                    {
                        condition = $"propName == \"{param.JsonName}\"";
                    }

                    if (isFirst)
                    {
                        sb.AppendLine($"            if ({condition})");
                        isFirst = false;
                    }
                    else
                    {
                        sb.AppendLine($"            else if ({condition})");
                    }

                    sb.AppendLine("            {");
                    EmitCtorParamRead(sb, param, types, "                ");
                    sb.AppendLine("            }");
                }
            }
        }

        // Default: skip unknown properties
        if (!isFirst)
        {
            sb.AppendLine("            else");
            sb.AppendLine("            {");
            sb.AppendLine("                r.Skip();");
            sb.AppendLine("            }");
        }
        else
        {
            // No properties to match, just skip
            sb.AppendLine("            r.Skip();");
        }
    }

    private static void EmitHelpers(StringBuilder sb)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Helper methods for flexible property name matching during deserialization.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class FastJsonHelpers");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Compares two strings for equality, ignoring case.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static bool EqualsIgnoreCase(string? a, string? b)");
        sb.AppendLine("    {");
        sb.AppendLine("        return string.Equals(a, b, StringComparison.OrdinalIgnoreCase);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Compares two strings for equality, ignoring case and special characters (underscores and hyphens).");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static bool EqualsNormalized(string? input, string normalizedTarget)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (input is null) return false;");
        sb.AppendLine("        int ti = 0;");
        sb.AppendLine("        for (int i = 0; i < input.Length; i++)");
        sb.AppendLine("        {");
        sb.AppendLine("            char c = input[i];");
        sb.AppendLine("            if (c == '_' || c == '-') continue;");
        sb.AppendLine("            if (c >= 'A' && c <= 'Z') c = (char)(c + 32);");
        sb.AppendLine("            if (ti >= normalizedTarget.Length || c != normalizedTarget[ti]) return false;");
        sb.AppendLine("            ti++;");
        sb.AppendLine("        }");
        sb.AppendLine("        return ti == normalizedTarget.Length;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitModuleInitializer(StringBuilder sb, EquatableArray<TypeModel> types)
    {
        sb.AppendLine("internal static class FastJsonInitializer");
        sb.AppendLine("{");
        sb.AppendLine("    [ModuleInitializer]");
        sb.AppendLine("    internal static void Initialize()");
        sb.AppendLine("    {");

        foreach (var type in types)
        {
            var safeTypeName = GetSafeTypeName(type);
            sb.AppendLine($"        FastJsonWriter<{type.FullyQualifiedName}>.Write = {safeTypeName}Serializer.Write;");
            // Skip reader registration for anonymous types (write-only)
            if (!type.IsAnonymous)
            {
                sb.AppendLine($"        FastJsonReader<{type.FullyQualifiedName}>.Read = {safeTypeName}Deserializer.Read;");
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
    }

    private static string GetDefaultValue(string typeName, bool isNullable)
    {
        if (isNullable) return "default";

        return NormalizeTypeName(typeName) switch
        {
            "string" => "\"\"",
            "int" or "long" or "short" or "byte" or "sbyte" or "uint" or "ulong" or "ushort" => "0",
            "double" or "float" or "decimal" => "0",
            "bool" => "false",
            _ => "default!"
        };
    }

    private static string NormalizeTypeName(string typeName)
    {
        // Remove global:: prefix and handle common type mappings
        var normalized = typeName;
        if (normalized.StartsWith("global::"))
            normalized = normalized.Substring(8);

        return normalized switch
        {
            "System.String" => "string",
            "System.Int32" => "int",
            "System.Int64" => "long",
            "System.Int16" => "short",
            "System.Byte" => "byte",
            "System.SByte" => "sbyte",
            "System.UInt32" => "uint",
            "System.UInt64" => "ulong",
            "System.UInt16" => "ushort",
            "System.Double" => "double",
            "System.Single" => "float",
            "System.Decimal" => "decimal",
            "System.Boolean" => "bool",
            _ => normalized
        };
    }

    private static bool IsValueTypeName(string typeName)
    {
        var normalized = NormalizeTypeName(typeName);
        return normalized switch
        {
            "int" or "long" or "short" or "byte" or "sbyte" or
            "uint" or "ulong" or "ushort" or
            "double" or "float" or "decimal" or
            "bool" or "char" or
            "System.DateTime" or "System.DateTimeOffset" or
            "System.Guid" or "System.DateOnly" or "System.TimeOnly" or
            "System.TimeSpan" => true,
            _ => false
        };
    }

    private static string GetSafeTypeName(TypeModel type)
    {
        return GetSafeTypeNameFromFqn(type.FullyQualifiedName);
    }

    private static string GetSafeTypeNameFromFqn(string fullyQualifiedName)
    {
        // Create a safe C# identifier from the type name
        var name = fullyQualifiedName;
        if (name.StartsWith("global::"))
            name = name.Substring(8);

        var sb = new StringBuilder();
        foreach (var c in name)
        {
            if (char.IsLetterOrDigit(c))
                sb.Append(c);
            else if (c == '.')
                sb.Append('_');
        }
        return sb.ToString();
    }

    private static string EscapeString(string s)
    {
        return s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    /// <summary>
    /// Converts a property name according to the specified naming policy.
    /// </summary>
    private static string ApplyNamingPolicy(string propertyName, int namingPolicy)
    {
        return namingPolicy switch
        {
            0 => propertyName, // None - keep as-is
            1 => ToCamelCase(propertyName), // CamelCase
            2 => ToSnakeCase(propertyName), // SnakeCase
            3 => ToKebabCase(propertyName), // KebabCase
            _ => propertyName
        };
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name))
            return name;

        if (char.IsLower(name[0]))
            return name;

        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    private static string ToSnakeCase(string name)
    {
        if (string.IsNullOrEmpty(name))
            return name;

        var sb = new StringBuilder();
        for (int i = 0; i < name.Length; i++)
        {
            char c = name[i];
            if (char.IsUpper(c))
            {
                if (i > 0)
                    sb.Append('_');
                sb.Append(char.ToLowerInvariant(c));
            }
            else
            {
                sb.Append(c);
            }
        }
        return sb.ToString();
    }

    private static string ToKebabCase(string name)
    {
        if (string.IsNullOrEmpty(name))
            return name;

        var sb = new StringBuilder();
        for (int i = 0; i < name.Length; i++)
        {
            char c = name[i];
            if (char.IsUpper(c))
            {
                if (i > 0)
                    sb.Append('-');
                sb.Append(char.ToLowerInvariant(c));
            }
            else
            {
                sb.Append(c);
            }
        }
        return sb.ToString();
    }

    /// <summary>
    /// Normalizes a property name by removing special characters and converting to lowercase.
    /// Used for generating comparison targets.
    /// </summary>
    private static string NormalizeForComparison(string name)
    {
        var sb = new StringBuilder();
        foreach (char c in name)
        {
            if (c != '_' && c != '-')
            {
                sb.Append(char.ToLowerInvariant(c));
            }
        }
        return sb.ToString();
    }

    public static string EmitWrapper(EquatableArray<TypeModel> types) => string.Empty;
}
