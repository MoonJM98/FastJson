using System.Text;
using FastJson.Generator.Models;

namespace FastJson.Generator;

/// <summary>
/// Generates AOT-compatible source code for FastJson serialization.
/// Creates JsonTypeInfo implementations using System.Text.Json metadata APIs
/// instead of relying on the built-in System.Text.Json source generator.
/// </summary>
/// <remarks>
/// <para>
/// The emitter generates a single file (FastJsonContext.g.cs) that contains:
/// </para>
/// <list type="bullet">
///   <item>A module initializer that configures FastJson at application startup</item>
///   <item>Configured JsonSerializerOptions with a custom IJsonTypeInfoResolver</item>
///   <item>Type-specific JsonTypeInfo&lt;T&gt; implementations for each collected type</item>
///   <item>Property metadata for object serialization/deserialization</item>
///   <item>Constructor parameter metadata for parameterized deserialization</item>
///   <item>Polymorphism options for types with [JsonPolymorphic] attributes</item>
/// </list>
/// <para>
/// The generated code is fully AOT-compatible and produces identical serialization
/// results to the standard System.Text.Json source generator.
/// </para>
/// </remarks>
public static class CodeEmitter
{
    /// <summary>
    /// Emits the FastJsonContext.g.cs file containing all serialization infrastructure.
    /// </summary>
    /// <param name="types">The collection of types to generate serialization code for.</param>
    /// <param name="options">The serialization options from [FastJsonOptions] attribute.</param>
    /// <returns>The complete source code for FastJsonContext.g.cs.</returns>
    public static string EmitContext(EquatableArray<TypeModel> types, FastJsonOptionsModel options)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type");
        sb.AppendLine("#pragma warning disable CS8601 // Possible null reference assignment");
        sb.AppendLine("#pragma warning disable CS8602 // Dereference of a possibly null reference");
        sb.AppendLine("#pragma warning disable CS8603 // Possible null reference return");
        sb.AppendLine("#pragma warning disable CS8604 // Possible null reference argument");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.IO;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine("using System.Text.Json.Serialization.Metadata;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine();
        sb.AppendLine("namespace FastJson;");
        sb.AppendLine();

        // Emit module initializer class
        sb.AppendLine("internal static class FastJsonInitializer");
        sb.AppendLine("{");
        sb.AppendLine("    [ModuleInitializer]");
        sb.AppendLine("    internal static void Initialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        FastJson.Configure(SerializeImpl, DeserializeImpl, SerializeAsyncImpl, DeserializeAsyncImpl);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Emit static options with TypeInfoResolver
        sb.AppendLine("    private static readonly JsonSerializerOptions _options = CreateOptions();");
        sb.AppendLine();
        sb.AppendLine("    private static JsonSerializerOptions CreateOptions()");
        sb.AppendLine("    {");
        sb.AppendLine("        var options = new JsonSerializerOptions");
        sb.AppendLine("        {");
        sb.AppendLine($"            PropertyNamingPolicy = {GetNamingPolicyCode(options.PropertyNamingPolicy)},");
        sb.AppendLine($"            WriteIndented = {options.WriteIndented.ToString().ToLower()},");
        sb.AppendLine($"            PropertyNameCaseInsensitive = {options.PropertyNameCaseInsensitive.ToString().ToLower()},");
        sb.AppendLine($"            AllowTrailingCommas = {options.AllowTrailingCommas.ToString().ToLower()},");
        sb.AppendLine("            IncludeFields = true,");
        if (options.DefaultIgnoreCondition)
        {
            sb.AppendLine("            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault,");
        }
        if (options.ReadCommentHandling)
        {
            sb.AppendLine("            ReadCommentHandling = JsonCommentHandling.Skip,");
        }
        sb.AppendLine("            // Chain our resolver with the default resolver for primitive types");
        sb.AppendLine("            TypeInfoResolver = JsonTypeInfoResolver.Combine(");
        sb.AppendLine("                FastJsonTypeInfoResolver.Instance,");
        sb.AppendLine("                new DefaultJsonTypeInfoResolver())");
        sb.AppendLine("        };");
        sb.AppendLine("        return options;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Emit SerializeImpl
        EmitSerializeImpl(sb, types);
        sb.AppendLine();

        // Emit DeserializeImpl
        EmitDeserializeImpl(sb, types);
        sb.AppendLine();

        // Emit SerializeAsyncImpl
        EmitSerializeAsyncImpl(sb, types);
        sb.AppendLine();

        // Emit DeserializeAsyncImpl
        EmitDeserializeAsyncImpl(sb, types);

        sb.AppendLine("}");
        sb.AppendLine();

        // Emit TypeInfoResolver
        EmitTypeInfoResolver(sb, types, options);

        return sb.ToString();
    }

    private static void EmitTypeInfoResolver(StringBuilder sb, EquatableArray<TypeModel> types, FastJsonOptionsModel options)
    {
        sb.AppendLine("internal sealed class FastJsonTypeInfoResolver : IJsonTypeInfoResolver");
        sb.AppendLine("{");
        sb.AppendLine("    public static FastJsonTypeInfoResolver Instance { get; } = new();");
        sb.AppendLine();
        sb.AppendLine("    private readonly Dictionary<Type, JsonTypeInfo> _cache = new();");
        sb.AppendLine("    private readonly object _lock = new();");
        sb.AppendLine();
        sb.AppendLine("    public JsonTypeInfo? GetTypeInfo(Type type, JsonSerializerOptions options)");
        sb.AppendLine("    {");
        sb.AppendLine("        lock (_lock)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (_cache.TryGetValue(type, out var cached))");
        sb.AppendLine("                return cached;");
        sb.AppendLine();
        sb.AppendLine("            var info = CreateTypeInfo(type, options);");
        sb.AppendLine("            if (info != null)");
        sb.AppendLine("            {");
        sb.AppendLine("                _cache[type] = info;");
        sb.AppendLine("            }");
        sb.AppendLine("            return info;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private JsonTypeInfo? CreateTypeInfo(Type type, JsonSerializerOptions options)");
        sb.AppendLine("    {");

        foreach (var type in types)
        {
            sb.AppendLine($"        if (type == typeof({type.FullyQualifiedName}))");
            sb.AppendLine($"            return Create_{type.ContextPropertyName}(options);");
            sb.AppendLine();
        }

        sb.AppendLine("        return null;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Emit Create methods for each type
        foreach (var type in types)
        {
            EmitCreateTypeInfo(sb, type, options);
            sb.AppendLine();
        }

        sb.AppendLine("}");
    }

    private static void EmitCreateTypeInfo(StringBuilder sb, TypeModel type, FastJsonOptionsModel options)
    {
        sb.AppendLine($"    private static JsonTypeInfo<{type.FullyQualifiedName}> Create_{type.ContextPropertyName}(JsonSerializerOptions options)");
        sb.AppendLine("    {");

        // If type has a custom converter, use it
        if (type.ConverterTypeName != null)
        {
            sb.AppendLine($"        return JsonMetadataServices.CreateValueInfo<{type.FullyQualifiedName}>(options, new {type.ConverterTypeName}());");
            sb.AppendLine("    }");
        }
        else if (type.IsEnum)
        {
            // Enum types - let the default resolver handle it, or use string converter if configured
            sb.AppendLine($"        return JsonMetadataServices.CreateValueInfo<{type.FullyQualifiedName}>(options, JsonMetadataServices.GetEnumConverter<{type.FullyQualifiedName}>(options));");
            sb.AppendLine("    }");
        }
        else if (type.IsCollection)
        {
            EmitCollectionTypeInfo(sb, type);
            sb.AppendLine("    }");
        }
        else
        {
            // EmitObjectTypeInfo handles its own method closing and adds helper methods
            EmitObjectTypeInfo(sb, type, options);
        }
    }

    private static void EmitCollectionTypeInfo(StringBuilder sb, TypeModel type)
    {
        if (type.KeyTypeName != null && type.ValueTypeName != null)
        {
            // Dictionary type
            sb.AppendLine($"        var info = JsonMetadataServices.CreateDictionaryInfo<{type.FullyQualifiedName}, {type.KeyTypeName}, {type.ValueTypeName}>(");
            sb.AppendLine("            options,");
            sb.AppendLine($"            new JsonCollectionInfoValues<{type.FullyQualifiedName}>()");
            sb.AppendLine("            {");
            sb.AppendLine($"                ObjectCreator = static () => new {type.FullyQualifiedName}(),");
            sb.AppendLine($"                KeyInfo = (JsonTypeInfo<{type.KeyTypeName}>)options.GetTypeInfo(typeof({type.KeyTypeName}))!,");
            sb.AppendLine($"                ElementInfo = (JsonTypeInfo<{type.ValueTypeName}>)options.GetTypeInfo(typeof({type.ValueTypeName}))!");
            sb.AppendLine("            });");
        }
        else if (type.ElementTypeName != null)
        {
            // List/Array type
            if (type.FullyQualifiedName.EndsWith("[]"))
            {
                // Array
                sb.AppendLine($"        var info = JsonMetadataServices.CreateArrayInfo<{type.ElementTypeName}>(");
                sb.AppendLine("            options,");
                sb.AppendLine($"            new JsonCollectionInfoValues<{type.ElementTypeName}[]>()");
                sb.AppendLine("            {");
                sb.AppendLine($"                ElementInfo = (JsonTypeInfo<{type.ElementTypeName}>)options.GetTypeInfo(typeof({type.ElementTypeName}))!");
                sb.AppendLine("            });");
            }
            else
            {
                // List
                sb.AppendLine($"        var info = JsonMetadataServices.CreateListInfo<{type.FullyQualifiedName}, {type.ElementTypeName}>(");
                sb.AppendLine("            options,");
                sb.AppendLine($"            new JsonCollectionInfoValues<{type.FullyQualifiedName}>()");
                sb.AppendLine("            {");
                sb.AppendLine($"                ObjectCreator = static () => new {type.FullyQualifiedName}(),");
                sb.AppendLine($"                ElementInfo = (JsonTypeInfo<{type.ElementTypeName}>)options.GetTypeInfo(typeof({type.ElementTypeName}))!");
                sb.AppendLine("            });");
            }
        }
        else
        {
            // Fallback for unknown collection types
            sb.AppendLine($"        throw new NotSupportedException(\"Collection type {type.FullyQualifiedName} is not supported.\");");
            sb.AppendLine($"        #pragma warning disable CS0162");
            sb.AppendLine($"        return null!;");
            sb.AppendLine($"        #pragma warning restore CS0162");
            return;
        }

        sb.AppendLine("        return info;");
    }

    private static void EmitObjectTypeInfo(StringBuilder sb, TypeModel type, FastJsonOptionsModel options)
    {
        bool useParameterizedCtor = type.ConstructorParameters.Length > 0 && !type.HasParameterlessConstructor;

        sb.AppendLine($"        var info = JsonMetadataServices.CreateObjectInfo<{type.FullyQualifiedName}>(");
        sb.AppendLine("            options,");
        sb.AppendLine($"            new JsonObjectInfoValues<{type.FullyQualifiedName}>()");
        sb.AppendLine("            {");

        // For abstract types, ObjectCreator must be null
        if (type.IsAbstract)
        {
            sb.AppendLine("                ObjectCreator = null,");
        }
        else if (useParameterizedCtor)
        {
            // Use parameterized constructor
            sb.AppendLine("                ObjectCreator = null,");
            sb.AppendLine($"                ObjectWithParameterizedConstructorCreator = static args => Create_{type.ContextPropertyName}_FromArgs(args),");
            sb.AppendLine($"                ConstructorParameterMetadataInitializer = static () => Create_{type.ContextPropertyName}_CtorParams(),");
        }
        else if (type.HasParameterlessConstructor)
        {
            sb.AppendLine($"                ObjectCreator = static () => new {type.FullyQualifiedName}(),");
        }
        else
        {
            sb.AppendLine("                ObjectCreator = null,");
        }

        // Use _ to ignore the context parameter and capture options directly
        sb.AppendLine($"                PropertyMetadataInitializer = _ => Create_{type.ContextPropertyName}_Properties(options),");
        sb.AppendLine("                SerializeHandler = null");
        sb.AppendLine("            });");

        // Add polymorphism options if this type is polymorphic
        if (type.IsPolymorphic && type.DerivedTypes.Length > 0)
        {
            sb.AppendLine();
            sb.AppendLine("        // Configure polymorphism");
            sb.AppendLine("        info.PolymorphismOptions = new JsonPolymorphismOptions");
            sb.AppendLine("        {");
            sb.AppendLine($"            TypeDiscriminatorPropertyName = \"{type.TypeDiscriminatorPropertyName ?? "$type"}\",");
            sb.AppendLine("            IgnoreUnrecognizedTypeDiscriminators = false,");
            sb.AppendLine("            UnknownDerivedTypeHandling = JsonUnknownDerivedTypeHandling.FailSerialization");
            sb.AppendLine("        };");

            foreach (var derived in type.DerivedTypes)
            {
                if (derived.TypeDiscriminator != null)
                {
                    if (derived.IsStringDiscriminator)
                    {
                        sb.AppendLine($"        info.PolymorphismOptions.DerivedTypes.Add(new JsonDerivedType(typeof({derived.TypeFullyQualifiedName}), \"{derived.TypeDiscriminator}\"));");
                    }
                    else
                    {
                        sb.AppendLine($"        info.PolymorphismOptions.DerivedTypes.Add(new JsonDerivedType(typeof({derived.TypeFullyQualifiedName}), {derived.TypeDiscriminator}));");
                    }
                }
                else
                {
                    sb.AppendLine($"        info.PolymorphismOptions.DerivedTypes.Add(new JsonDerivedType(typeof({derived.TypeFullyQualifiedName})));");
                }
            }
        }

        sb.AppendLine("        return info;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Emit property metadata method
        EmitPropertyMetadata(sb, type, options);

        // Emit constructor methods if using parameterized constructor
        if (useParameterizedCtor && !type.IsAbstract)
        {
            sb.AppendLine();
            EmitConstructorMethods(sb, type, options);
        }
    }

    private static void EmitConstructorMethods(StringBuilder sb, TypeModel type, FastJsonOptionsModel options)
    {
        // Emit constructor parameter metadata
        sb.AppendLine($"    private static JsonParameterInfoValues[] Create_{type.ContextPropertyName}_CtorParams()");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new JsonParameterInfoValues[{type.ConstructorParameters.Length}]");
        sb.AppendLine("        {");

        foreach (var param in type.ConstructorParameters)
        {
            sb.AppendLine($"            new JsonParameterInfoValues()");
            sb.AppendLine("            {");
            sb.AppendLine($"                Name = \"{param.Name}\",");
            sb.AppendLine($"                ParameterType = typeof({param.TypeFullyQualifiedName}),");
            sb.AppendLine($"                Position = {param.Position},");
            sb.AppendLine($"                HasDefaultValue = {param.HasDefaultValue.ToString().ToLower()},");
            if (param.HasDefaultValue && param.DefaultValueString != null)
            {
                sb.AppendLine($"                DefaultValue = {param.DefaultValueString},");
            }
            sb.AppendLine("            },");
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Emit object creation from args
        sb.AppendLine($"    private static {type.FullyQualifiedName} Create_{type.ContextPropertyName}_FromArgs(object[] args)");
        sb.AppendLine("    {");
        sb.Append($"        return new {type.FullyQualifiedName}(");

        var paramList = new System.Collections.Generic.List<string>();
        foreach (var param in type.ConstructorParameters)
        {
            paramList.Add($"({param.TypeFullyQualifiedName})args[{param.Position}]!");
        }
        sb.Append(string.Join(", ", paramList));

        sb.AppendLine(");");
        sb.AppendLine("    }");
    }

    private static void EmitPropertyMetadata(StringBuilder sb, TypeModel type, FastJsonOptionsModel options)
    {
        sb.AppendLine($"    private static JsonPropertyInfo[] Create_{type.ContextPropertyName}_Properties(JsonSerializerOptions options)");
        sb.AppendLine("    {");

        // Filter out ignored properties
        var visibleProperties = new System.Collections.Generic.List<PropertyModel>();
        foreach (var p in type.Properties)
        {
            if (!p.IsIgnored)
                visibleProperties.Add(p);
        }

        if (visibleProperties.Count == 0)
        {
            sb.AppendLine("        return Array.Empty<JsonPropertyInfo>();");
        }
        else
        {
            sb.AppendLine($"        var properties = new JsonPropertyInfo[{visibleProperties.Count}];");
            sb.AppendLine();

            var index = 0;
            foreach (var prop in visibleProperties)
            {
                // Use prop.JsonName which includes [JsonPropertyName] value or camelCase name
                var jsonName = prop.JsonName;

                sb.AppendLine($"        properties[{index}] = JsonMetadataServices.CreatePropertyInfo<{prop.TypeFullyQualifiedName}>(");
                sb.AppendLine("            options,");
                sb.AppendLine($"            new JsonPropertyInfoValues<{prop.TypeFullyQualifiedName}>()");
                sb.AppendLine("            {");
                sb.AppendLine($"                IsProperty = {(!prop.IsField).ToString().ToLower()},");
                sb.AppendLine($"                IsPublic = {prop.IsPublic.ToString().ToLower()},");
                sb.AppendLine($"                DeclaringType = typeof({type.FullyQualifiedName}),");
                sb.AppendLine($"                PropertyName = \"{prop.Name}\",");
                sb.AppendLine($"                JsonPropertyName = \"{jsonName}\",");

                if (prop.HasGetter)
                {
                    sb.AppendLine($"                Getter = static obj => (({type.FullyQualifiedName})obj).{prop.Name},");
                }
                else
                {
                    sb.AppendLine("                Getter = null,");
                }

                // Don't generate setter for init-only properties (records) - they can only be set via constructor
                if (prop.HasSetter && !prop.IsInitOnly)
                {
                    sb.AppendLine($"                Setter = static (obj, val) => (({type.FullyQualifiedName})obj).{prop.Name} = val,");
                }
                else
                {
                    sb.AppendLine("                Setter = null,");
                }

                if (prop.IsRequired)
                {
                    sb.AppendLine("                IsRequired = true,");
                }

                if (prop.NumberHandling != null)
                {
                    sb.AppendLine($"                NumberHandling = {prop.NumberHandling},");
                }

                if (prop.ConverterTypeName != null)
                {
                    sb.AppendLine($"                JsonTypeInfo = JsonMetadataServices.CreateValueInfo<{prop.TypeFullyQualifiedName}>(options, new {prop.ConverterTypeName}()),");
                }

                sb.AppendLine("            });");
                sb.AppendLine();
                index++;
            }

            sb.AppendLine("        return properties;");
        }

        sb.AppendLine("    }");
    }

    /// <summary>
    /// Emits the FastJson.g.cs file - not needed in the new approach, returns empty string.
    /// </summary>
    public static string EmitWrapper(EquatableArray<TypeModel> types)
    {
        // No longer needed - all implementation is in the context file
        return string.Empty;
    }

    private static void EmitSerializeImpl(StringBuilder sb, EquatableArray<TypeModel> types)
    {
        sb.AppendLine("    private static string SerializeImpl(object? value, Type type)");
        sb.AppendLine("    {");

        foreach (var type in types)
        {
            sb.AppendLine($"        if (type == typeof({type.FullyQualifiedName}))");
            sb.AppendLine("        {");
            sb.AppendLine($"            return JsonSerializer.Serialize(({type.FullyQualifiedName}?)value, _options);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("        throw new InvalidOperationException($\"Type {type} is not registered for FastJson serialization. Add [assembly: FastJsonInclude(typeof({type}))] to register it.\");");
        sb.AppendLine("    }");
    }

    private static void EmitDeserializeImpl(StringBuilder sb, EquatableArray<TypeModel> types)
    {
        sb.AppendLine("    private static object? DeserializeImpl(string json, Type type)");
        sb.AppendLine("    {");

        foreach (var type in types)
        {
            sb.AppendLine($"        if (type == typeof({type.FullyQualifiedName}))");
            sb.AppendLine("        {");
            sb.AppendLine($"            return JsonSerializer.Deserialize<{type.FullyQualifiedName}>(json, _options);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("        throw new InvalidOperationException($\"Type {type} is not registered for FastJson deserialization. Add [assembly: FastJsonInclude(typeof({type}))] to register it.\");");
        sb.AppendLine("    }");
    }

    private static void EmitSerializeAsyncImpl(StringBuilder sb, EquatableArray<TypeModel> types)
    {
        sb.AppendLine("    private static Task SerializeAsyncImpl(Stream stream, object? value, Type type, CancellationToken cancellationToken)");
        sb.AppendLine("    {");

        foreach (var type in types)
        {
            sb.AppendLine($"        if (type == typeof({type.FullyQualifiedName}))");
            sb.AppendLine("        {");
            sb.AppendLine($"            return JsonSerializer.SerializeAsync(stream, ({type.FullyQualifiedName}?)value, _options, cancellationToken);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("        throw new InvalidOperationException($\"Type {type} is not registered for FastJson serialization. Add [assembly: FastJsonInclude(typeof({type}))] to register it.\");");
        sb.AppendLine("    }");
    }

    private static void EmitDeserializeAsyncImpl(StringBuilder sb, EquatableArray<TypeModel> types)
    {
        sb.AppendLine("    private static async ValueTask<object?> DeserializeAsyncImpl(Stream stream, Type type, CancellationToken cancellationToken)");
        sb.AppendLine("    {");

        foreach (var type in types)
        {
            sb.AppendLine($"        if (type == typeof({type.FullyQualifiedName}))");
            sb.AppendLine("        {");
            sb.AppendLine($"            return await JsonSerializer.DeserializeAsync<{type.FullyQualifiedName}>(stream, _options, cancellationToken).ConfigureAwait(false);");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        sb.AppendLine("        throw new InvalidOperationException($\"Type {type} is not registered for FastJson deserialization. Add [assembly: FastJsonInclude(typeof({type}))] to register it.\");");
        sb.AppendLine("    }");
    }

    private static string GetNamingPolicyCode(string policy)
    {
        return policy switch
        {
            "CamelCase" => "JsonNamingPolicy.CamelCase",
            "PascalCase" => "null", // null = no transformation
            "SnakeCaseLower" => "JsonNamingPolicy.SnakeCaseLower",
            "SnakeCaseUpper" => "JsonNamingPolicy.SnakeCaseUpper",
            "KebabCaseLower" => "JsonNamingPolicy.KebabCaseLower",
            "KebabCaseUpper" => "JsonNamingPolicy.KebabCaseUpper",
            _ => "JsonNamingPolicy.CamelCase"
        };
    }
}
